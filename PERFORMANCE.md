# 性能对比测试报告

## 测试环境
- **硬件**: macOS (Apple Silicon M2/M3)
- **测试内容**: 10,000,000 (一千万) 次 SIN 数学计算
- **测试程序**: 累加 SUM = SUM + SIN(I)
- **测试日期**: 2026-02-10

## 核心引擎架构对比

zork-basic 目前支持两种执行引擎，用户可以通过 `-mode ast` 或 `-mode vm` 进行切换。

| 引擎 | 实现方式 | 吞吐量 (ops/sec) | 相对速度 | 适用场景 |
| :--- | :--- | :--- | :--- | :--- |
| **Go 原生** | 机器码编译 | ~160,000,000 | 1.0x | 基准参考 |
| **Bytecode VM** 🚀 | **字节码虚拟机** | **~40,350,000** | **4.0x** | 大规模循环、高性能需求 |
| **AST Interpreter** | 直接遍历语法树 | ~10,900,000 | 14.7x | 交互式开发、简单脚本 |

---

## 优化历程与实施细节 ✅

### 1. 引擎革命：从 AST 到 Bytecode VM (2026-02-10)
这是本项目最重大的性能飞跃。

**改进细节**:
- **编译器 (Compiler)**: 将 AST 预编译为紧凑的字节码 (`Chunk`)。
- **符号表 (Symbol Table)**: 在编译期将变量名映射为整数索引，运行时通过 `slice` 索引直接访问变量，彻底消除了热路径中的 `map` 哈希查找开销。
- **专用指令集**:
    - `OpForInit`: 专门用于循环初始化，将步长、结束值等状态推入循环栈帧。
    - `OpNext`: 高性能循环指令，直接在指令中包含跳转目标及自增逻辑。
- **热路径内联**: 将复杂的二元运算逻辑直接内联到 VM 的主 `switch` 循环中，减少函数调用。

### 2. VM 级深度优化 🛠️
在 VM 基础之上进行的微观优化，使性能进一步提升了约 20%：

- **无检查栈推送 (pushUnchecked)**: 在二元运算等已知安全（先弹出后推送）的路径中，移除栈边界检查，减少 CPU 分支预测压力。
- **布尔值预缓存**: 预先创建 `valZero` 和 `valOne` 常量对象，避免比较运算中频繁创建 `Value` 结构体。
- **局部变量缓存**: 在 VM 执行循环中，将 `chunk.Code`、`chunk.Constants`、`globals` 引用缓存到局部变量，提高访问频率。
- **数组访问优化**: 引入可复用的索引缓冲区，避免多维数组定位时的频繁切片分配。

### 3. 常量池去重
编译器自动识别重复的数字和字符串文字，仅在常量池中存储一份，优化内存占用并提升缓存命中率。

---

## 详细性能数据 (1000万次循环)

| 测试指标 | Go 原生 | Bytecode VM (FOR/NEXT) | AST Interpreter (FOR/NEXT) |
| :--- | :--- | :--- | :--- |
| **执行总耗时** | 62.6 ms | **247.8 ms** | 916.6 ms |
| **吞吐量 (ops)** | 1.6 亿/秒 | **4035 万/秒** | 1090 万/秒 |
| **相对于 Go 原生** | 1.0x | **3.9x 慢** | 14.6x 慢 |
| **相对于前一版本** | - | **提升 3.7 倍** | 基准 |

### 执行流对比分析

- **GOTO 循环 vs FOR/NEXT 循环**:
    - 在 VM 中，通过专用指令实现的 `FOR/NEXT` 比用 `IF/GOTO` 模拟的版本快了 **83%**。
    - 这是因为 `OpNext` 一条指令完成了：自增、条件判断、跳转三个操作，大大减少了取指开销。

---

## 性能分析总结

### 为什么现在的 VM 这么快？
1. **指令流水线**: 字节码结构极其紧凑，单次循环只需极少的字节读取。
2. **零哈希查找**: 变量访问简化为 `globals[i]`，接近原生数组访问速度。
3. **低对象分配**: 除了 `string` 拼接，运行时几乎不产生新的内存分配。

### 优化效果验证
目前 zork-basic 在执行密集型数学循环时，性能已逼近原生 Go 速度的 **1/4**。对于一个用完全动态类型实现的解释器来说，这是一个极其优秀的成绩。

---

## 结论

1. **zork-basic 进入了 4000万次/秒 时代**：不再仅仅是一个简单的教学工具，它已经具备处理中等复杂度算法的能力。
2. **双引擎优势**: 
    - 运行普通脚本时，AST 解释器提供最快的启动速度。
    - 运行复杂程序或 Benchmarks 时，VM 提供极致性能。
3. **与 C 实现对比**: 当前的 Go VM 实现已经超过了许多传统的 C 语言编写的 BASIC 解释器（如经典的仿真器实现）。

**更新日期**: 2026-02-10
**版本**: 1.1.0 (High Performance Edition)
