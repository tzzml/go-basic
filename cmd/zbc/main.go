package main

import (
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"zork-basic/internal/ast"
	"zork-basic/internal/compiler"
	"zork-basic/internal/parser"
)

func main() {
	var outputFile string
	var dump bool
	flag.StringVar(&outputFile, "o", "", "Output bytecode file (default: input with .zbc extension)")
	flag.BoolVar(&dump, "d", false, "Disassemble generated bytecode")
	flag.Usage = func() {
		fmt.Fprintf(os.Stderr, "Usage: %s [options] <source_file>\n", os.Args[0])
		flag.PrintDefaults()
	}
	flag.Parse()

	if flag.NArg() < 1 {
		flag.Usage()
		os.Exit(1)
	}

	inputFile := flag.Arg(0)
	if outputFile == "" {
		ext := filepath.Ext(inputFile)
		outputFile = strings.TrimSuffix(inputFile, ext) + ".zbc"
	}

	content, err := os.ReadFile(inputFile)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error reading source: %v\n", err)
		os.Exit(1)
	}

	// Parse
	prog, err := parser.Parse(inputFile, content)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Parse error: %v\n", err)
		os.Exit(1)
	}

	// Compile
	comp := compiler.New()
	chunk, err := comp.Compile(prog.(*ast.Program))
	if err != nil {
		fmt.Fprintf(os.Stderr, "Compile error: %v\n", err)
		os.Exit(1)
	}

	// Write
	f, err := os.Create(outputFile)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error creating output file: %v\n", err)
		os.Exit(1)
	}
	defer f.Close()

	if err := chunk.Write(f); err != nil {
		fmt.Fprintf(os.Stderr, "Error writing bytecode: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Successfully compiled %s to %s\n", inputFile, outputFile)

	if dump {
		fmt.Println("\nDisassembly:")
		fmt.Println(chunk.Disassemble(inputFile))
	}
}
